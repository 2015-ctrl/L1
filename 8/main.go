package main

import (
	"fmt"
)

/*
Функция I1 устанавливает i-й бит числа n в 1.
- Мы считаем биты с 1 (т.е. i = 1 → младший (LSB) бит, i = 64 → старший бит для int64).
- Операция 1 << (i-1) создаёт маску, в которой ровно один бит равен 1,
  а все остальные — 0. Сдвиг на (i-1) потому, что нумерация битов с 1,
  а сдвиг работает с индексом с нуля.
- Побитовое ИЛИ (|) с маской гарантированно выставит нужный бит в 1,
  сохраняя все остальные биты числа n без изменений.
*/
func I1(n int64, i int) int64 {
	// Сдвигаем единицу на (i-1) позиций и делаем побитовое OR с n
	// Пример: n = 5 (0101₂), i = 2 → маска = 1 << 1 = 0010₂,
	// 0101 | 0010 = 0111 (7)
	return n | 1<<(i-1)
}

/*
Функция I0 устанавливает i-й бит числа n в 0.
- Операция (1 << (i-1)) создаёт маску с единичным битом.
- Оператор &^ в Go — "AND NOT" (логическое И с инверсией второго операнда).
  Выражение n &^ mask обнуляет биты n, которые равны 1 в mask, и оставляет
  остальные битовые позиции без изменения.
- Таким образом n &^ (1<<(i-1)) гарантированно обнуляет i-й бит.
*/
func I0(n int64, i int) int64 {
	// n &^ mask — обнуляет биты в n, которые указаны в mask.
	// Пример: n = 5 (0101₂), i = 1 → mask = 1 << 0 = 0001₂,
	// 0101 &^ 0001 = 0100 (4)
	return n &^ (1 << (i - 1))
}

func main() {
	fmt.Println(I1(5, 2))
	fmt.Println(I0(5, 1))
}
