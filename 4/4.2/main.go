package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

// worker — функция-воркер, которая получает данные из канала.
// Она работает в отдельной горутине.
func worker(ctx context.Context, id int, ch <-chan int) {
	for {
		select {
		// Если контекст отменен (получили сигнал завершения) —
		// воркер выходит из цикла и завершает работу.
		case <-ctx.Done():
			fmt.Printf("Worker %d завершает работу\n", id)
			return

		// Чтение данных из канала. Если канал закрыт, то val = 0,
		// и воркер завершится сам.
		case val := <-ch:
			fmt.Printf("Worker %d получил %d\n", id, val)
		}
	}
}

func main() {
	var n int
	fmt.Println("Введите N воркеров:")
	// Считываем количество воркеров с консоли
	fmt.Scan(&n)

	// Создаем канал для передачи данных воркерам
	ch := make(chan int)

	// Создаем контекст с функцией отмены (cancel).
	// Контекст нужен, чтобы "разослать" сигнал завершения всем воркерам.
	ctx, cancel := context.WithCancel(context.Background())

	// Создаем канал для получения системных сигналов
	sigCh := make(chan os.Signal, 1)

	// Регистрируем канал для перехвата сигналов ОС:
	// SIGINT (Ctrl+C) и SIGTERM (остановка процесса).
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

	// Запускаем N воркеров в отдельных горутинах
	for i := 1; i <= n; i++ {
		go worker(ctx, i, ch)
	}

	// Отдельная горутина для обработки сигнала завершения
	go func() {
		<-sigCh // Ждем пока в канал придет сигнал (например, Ctrl+C)
		fmt.Println("\nПолучен сигнал завершения. Останавливаем воркеров...")

		cancel()  // Отправляем "отмену" через контекст всем воркерам
		close(ch) // Закрываем канал, чтобы воркеры больше не ждали данные
	}()

	// Главная горутина — источник данных.
	// Она постоянно пишет числа в канал.
	for i := 1; ; i++ {
		select {
		// Если контекст отменен (cancel вызван), завершаем main
		case <-ctx.Done():
			fmt.Println("Главная горутина завершает работу")
			return
		default:
			// Отправляем число i в канал
			ch <- i
			// Делаем паузу, чтобы вывод был читаемым
			time.Sleep(500 * time.Millisecond)
		}
	}
}
